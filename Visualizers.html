<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Visualizers</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap');
        body {
            font-family: 'Inter', sans-serif;
        }
        .glass {
            background: rgba(255, 255, 255, 0.7);
            backdrop-filter: blur(20px) saturate(180%);
            box-shadow: 0 12px 32px rgba(6,182,212,0.13), 0 1.5px 12px rgba(45,212,191,0.06);
        }
        .dark .glass {
            background: rgba(21, 28, 35, 0.82);
            box-shadow: 0 12px 32px rgba(20,184,166,0.17), 0 1.5px 12px rgba(34,197,94,0.08);
        }
        .frost-border {
            border: 4px solid rgba(255,255,255,0.95);
        }
        .dark .frost-border {
            border: 4px solid rgba(31, 41, 55, 0.7);
        }
        .avatar-glow {
            content: '';
            position: absolute;
            inset: 0;
            border-radius: 9999px;
            z-index: -1;
            pointer-events: none;
            background: conic-gradient(
                from 90deg at 58% 50%,
                #06b6d4 0deg,
                #14b8a6 45deg,
                #a5f3fc 180deg,
                #0f766e 270deg,
                #06b6d4 360deg
            );
            opacity: 0.22;
            filter: blur(16px);
            animation: glow-spin2 5s linear infinite;
        }
        @keyframes glow-spin2 {
            to { transform: rotate(360deg); }
        }
        .skill-chip {
            border: 2px solid #06b6d4;
            background: rgba(6,182,212,0.09);
            color: #164e63;
            padding: 0.35em 1.05em;
            border-radius: 999px;
            font-weight: 600;
            font-size: 0.98em;
            margin-bottom: 0.3em;
            margin-right: 0.4em;
            display: inline-block;
            transition: border 0.2s, background 0.2s, color 0.2s, transform .18s;
        }
        .skill-chip:hover {
            border: 2.5px solid #22d3ee;
            background: #a5f3fc;
            color: #075985;
            transform: scale(1.07);
        }
        .dark .skill-chip {
            border: 2px solid #14b8a6;
            background: rgba(13,148,136,0.13);
            color: #a7f3d0;
        }
        .dark .skill-chip:hover {
            border: 2.5px solid #34d399;
            background: #115e59;
            color: #6ee7b7;
        }
        .back-link { transition: all 0.2s; }
        .back-link:hover { transform: translateX(-6px) scale(1.07); }

        /* Binary tree circle styles */
        #treeBox {
            min-height: 120px;
            padding: 12px;
            position: relative; /* needed for connector SVG positioning */
        }
        .tree-level {
            width: 100%;
            display: flex;
            justify-content: center;
            gap: 1rem;
            align-items: flex-start;
        }
        .node-wrap {
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative;
            min-width: 56px; /* keeps layout stable */
            z-index: 2; /* so nodes are above connector SVG */
        }
        .tree-node {
            width: 48px;
            height: 48px;
            border-radius: 9999px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #06202a;
            font-weight: 700;
            box-shadow: 0 6px 18px rgba(99,102,241,0.08), 0 2px 6px rgba(99,102,241,0.04);
            border: 2px solid rgba(0,0,0,0.06);
            user-select: none;
            transition: transform .15s, box-shadow .15s, opacity .12s;
        }
        .tree-node.internal {
            background: #60f0f3; /* cyan internal */
            color: #042D2F;
        }
        .tree-node.leaf {
            background: #7EE787; /* green leaf */
            color: #07360a;
        }
        .tree-node.highlight {
            transform: scale(1.14);
            box-shadow: 0 8px 22px rgba(0,0,0,0.14), 0 2px 8px rgba(20,184,166,0.14);
            outline: 4px solid rgba(255,255,255,0.25);
        }
        .tree-node:active { transform: scale(0.98); }

        .connector {
            width: 2px;
            height: 14px;
            margin-top: 6px;
            background: linear-gradient(180deg, rgba(59,130,246,0.9), rgba(124,58,237,0.9));
            border-radius: 2px;
        }

        /* traversal output */
        #traversalOutput {
            margin-top: 8px;
            padding: 8px;
            min-height: 34px;
            background: rgba(0,0,0,0.04);
            border-radius: 8px;
            font-weight: 600;
            color: #0f172a;
        }

        /* small responsive tweaks */
        @media (max-width: 640px) {
            .tree-node { width: 40px; height: 40px; font-size: 0.9rem; }
            .node-wrap { min-width: 44px; gap: 0.25rem; }
            .tree-level { gap: 0.5rem; }
        }
    </style>
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    colors: {
                        'primary': '#06b6d4',
                        'primary-dark': '#0d9488'
                    }
                }
            }
        }
    </script>
</head>
<body class="min-h-screen flex items-center justify-center bg-gradient-to-br from-cyan-100 via-cyan-300 to-blue-50 dark:from-gray-900 dark:via-teal-900 dark:to-gray-900 text-gray-900">
    <main class="w-full py-12">
        <header class="w-full max-w-4xl mx-auto mb-2 px-4 flex justify-between items-center sticky top-0 z-30 bg-transparent">
            <a href="index.html" class="back-link flex items-center gap-2 text-lg font-bold text-cyan-600 dark:text-teal-300">
                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 19l-7-7m0 0l7-7m-7 7h18"/>
                </svg>
                Back To Main
            </a>
        </header>

        <!-- ================= INTERACTIVE VISUALIZERS ================= -->
        <section class="card p-6 bg-white rounded-xl shadow max-w-4xl mx-auto">
            <h2 class="text-xl font-bold">Interactive Visualizers</h2>
            <p class="text-sm text-gray-600">Use the controls below to interact with the data structures.</p>

            <!-- STACK -->
            <div class="mt-6">
                <h3 class="font-semibold">Stack (LIFO)</h3>
                <div class="flex gap-2 mt-2">
                    <input id="stackInput" inputmode="numeric" maxlength="5" class="border rounded px-2 py-1" placeholder="numeric value (max 5 digits)">
                    <button id="stackPushBtn" class="px-3 py-1 bg-teal-500 text-white rounded">Push</button>
                    <button id="stackPopBtn" class="px-3 py-1 bg-rose-500 text-white rounded">Pop</button>
                    <button id="stackClearBtn" class="px-3 py-1 bg-gray-300 rounded">Clear</button>
                    <div id="stackNotice" class="text-sm text-red-600 pl-3"></div>
                </div>
                <div id="stackBox" class="mt-3 flex flex-col-reverse gap-1 border p-3 rounded max-h-[200px] overflow-y-auto"></div>
                <div class="text-xs text-gray-500 mt-1">Max items: 5</div>
            </div>

            <!-- QUEUE -->
            <div class="mt-8">
                <h3 class="font-semibold">Queue (FIFO)</h3>
                <div class="flex gap-2 mt-2">
                    <input id="queueInput" inputmode="numeric" maxlength="5" class="border rounded px-2 py-1" placeholder="numeric value (max 5 digits)">
                    <button id="queueEnqBtn" class="px-3 py-1 bg-teal-500 text-white rounded">Enqueue</button>
                    <button id="queueDeqBtn" class="px-3 py-1 bg-rose-500 text-white rounded">Dequeue</button>
                    <button id="queueClearBtn" class="px-3 py-1 bg-gray-300 rounded">Clear</button>
                    <div id="queueNotice" class="text-sm text-red-600 pl-3"></div>
                </div>
                <div id="queueBox" class="mt-3 flex gap-1 border p-3 rounded min-h-[60px]"></div>
                <div class="text-xs text-gray-500 mt-1">Max items: 5</div>
            </div>

            <!-- BINARY SEARCH TREE -->
            <div class="mt-8">
                <h3 class="font-semibold">Binary Search Tree (BST)</h3>
                <div class="flex flex-wrap gap-2 mt-2">
                    <input id="treeInput" class="border rounded px-2 py-1" placeholder="numeric value">
                    <button id="treeInsertBtn" class="px-3 py-1 bg-teal-500 text-white rounded">Insert</button>
                    <button id="inorderBtn" class="px-3 py-1 bg-indigo-500 text-white rounded">Inorder</button>
                    <button id="preorderBtn" class="px-3 py-1 bg-indigo-500 text-white rounded">Preorder</button>
                    <button id="postorderBtn" class="px-3 py-1 bg-indigo-500 text-white rounded">Postorder</button>
                    <button id="loadExampleBtn" class="px-3 py-1 bg-emerald-500 text-white rounded">Load Perfect Example</button>
                    <button id="treeClearBtn" class="px-3 py-1 bg-gray-300 rounded">Clear</button>
                </div>
                <div id="treeBox" class="mt-3 flex gap-2 flex-wrap border p-3 rounded min-h-[70px]"></div>

                <!-- traversal output and guidance -->
                <div id="traversalOutput" aria-live="polite">Traversal output will appear here.</div>
                <div class="text-xs text-gray-500 mt-1">Example Perfect Binary Tree has nodes 1..15 (levels shown visually by structure).</div>
            </div>
        </section>

        <script>
            // Wait until DOM loaded to bind elements
            document.addEventListener('DOMContentLoaded', () => {
                // Elements
                const stackInput = document.getElementById('stackInput');
                const stackBox = document.getElementById('stackBox');
                const stackPushBtn = document.getElementById('stackPushBtn');
                const stackPopBtn = document.getElementById('stackPopBtn');
                const stackClearBtn = document.getElementById('stackClearBtn');
                const stackNotice = document.getElementById('stackNotice');

                const queueInput = document.getElementById('queueInput');
                const queueBox = document.getElementById('queueBox');
                const queueEnqBtn = document.getElementById('queueEnqBtn');
                const queueDeqBtn = document.getElementById('queueDeqBtn');
                const queueClearBtn = document.getElementById('queueClearBtn');
                const queueNotice = document.getElementById('queueNotice');

                const treeInput = document.getElementById('treeInput');
                const treeBox = document.getElementById('treeBox');
                const treeInsertBtn = document.getElementById('treeInsertBtn');
                const treeClearBtn = document.getElementById('treeClearBtn');
                const inorderBtn = document.getElementById('inorderBtn');
                const preorderBtn = document.getElementById('preorderBtn');
                const postorderBtn = document.getElementById('postorderBtn');
                const loadExampleBtn = document.getElementById('loadExampleBtn');
                const traversalOutput = document.getElementById('traversalOutput');

                // Settings
                const MAX_ITEMS = 5;

                // STACK (LIFO)
                let stack = [];

                function updateStackControls() {
                    stackPushBtn.disabled = stack.length >= MAX_ITEMS;
                    stackPopBtn.disabled = stack.length === 0;
                    stackNotice.textContent = stack.length >= MAX_ITEMS ? 'Overflow: stack has reached max (5).' : '';
                }

                function renderStack() {
                    stackBox.innerHTML = '';
                    for (let i = stack.length - 1; i >= 0; i--) {
                        const d = document.createElement('div');
                        d.className = 'px-3 py-1 bg-blue-200 rounded text-center';
                        d.textContent = stack[i];
                        stackBox.appendChild(d);
                    }
                    updateStackControls();
                }

                function stackPush() {
                    const v = stackInput.value.trim();
                    if (!/^-?\d+$/.test(v)) {
                        alert('Enter a valid integer number.');
                        return;
                    }
                    if (stack.length >= MAX_ITEMS) {
                        alert('Stack overflow: maximum of ' + MAX_ITEMS + ' items allowed.');
                        updateStackControls();
                        return;
                    }
                    stack.push(Number(v));
                    stackInput.value = '';
                    renderStack();
                }

                function stackPop() {
                    if (!stack.length) {
                        alert('Stack is empty');
                        return;
                    }
                    stack.pop();
                    renderStack();
                }

                function stackClear() {
                    stack = [];
                    renderStack();
                }

                // QUEUE (FIFO)
                let queue = [];

                function updateQueueControls() {
                    queueEnqBtn.disabled = queue.length >= MAX_ITEMS;
                    queueDeqBtn.disabled = queue.length === 0;
                    queueNotice.textContent = queue.length >= MAX_ITEMS ? 'Overflow: queue has reached max (5).' : '';
                }

                function renderQueue() {
                    queueBox.innerHTML = '';
                    queue.forEach(v => {
                        const d = document.createElement('div');
                        d.className = 'px-3 py-1 bg-green-200 rounded';
                        d.textContent = v;
                        queueBox.appendChild(d);
                    });
                    updateQueueControls();
                }

                function queueEnq() {
                    const v = queueInput.value.trim();
                    if (!/^-?\d+$/.test(v)) {
                        alert('Enter a valid integer number.');
                        return;
                    }
                    if (queue.length >= MAX_ITEMS) {
                        alert('Queue overflow: maximum of ' + MAX_ITEMS + ' items allowed.');
                        updateQueueControls();
                        return;
                    }
                    queue.push(Number(v));
                    queueInput.value = '';
                    renderQueue();
                }

                function queueDeq() {
                    if (!queue.length) {
                        alert('Queue is empty');
                        return;
                    }
                    queue.shift();
                    renderQueue();
                }

                function queueClear() {
                    queue = [];
                    renderQueue();
                }

                // BINARY SEARCH TREE (simple implementation) with visual connectors
                class Node {
                    constructor(v) {
                        this.v = v;
                        this.l = null;
                        this.r = null;
                        this.id = Node._nextId++;
                    }
                }
                Node._nextId = 1;

                let root = null;
                let lastLevels = null; // keep latest levels for redraws

                function insertNode(n, v) {
                    if (!n) return new Node(v);
                    if (v < n.v) n.l = insertNode(n.l, v);
                    else n.r = insertNode(n.r, v);
                    return n;
                }

                function treeInsert() {
                    const raw = treeInput.value.trim();
                    if (!/^-?\d+$/.test(raw)) {
                        alert('Enter a valid integer number.');
                        return;
                    }
                    const v = Number(raw);
                    root = insertNode(root, v);
                    treeInput.value = '';
                    renderTree();
                }

                function treeClear() {
                    root = null;
                    Node._nextId = 1;
                    renderTree();
                    traversalOutput.textContent = 'Traversal output will appear here.';
                }

                // New: render tree as rows of circular nodes (level-order) and draw SVG connectors
                function renderTree() {
                    treeBox.innerHTML = '';
                    if (!root) {
                        lastLevels = null;
                        return;
                    }

                    // build levels via BFS
                    const levels = [];
                    const q = [{ node: root, lvl: 0 }];
                    while (q.length) {
                        const { node, lvl } = q.shift();
                        if (!levels[lvl]) levels[lvl] = [];
                        levels[lvl].push(node);
                        if (node.l) q.push({ node: node.l, lvl: lvl + 1 });
                        if (node.r) q.push({ node: node.r, lvl: lvl + 1 });
                    }

                    // render each level as a centered row
                    levels.forEach((nodes) => {
                        const row = document.createElement('div');
                        row.className = 'tree-level';
                        nodes.forEach(n => {
                            const wrap = document.createElement('div');
                            wrap.className = 'node-wrap';

                            const nd = document.createElement('div');
                            nd.className = 'tree-node';
                            nd.textContent = n.v;
                            // store mapping to node id and value so we can measure later / locate node by value
                            nd.dataset.nodeId = n.id;
                            nd.dataset.value = n.v;
                            // style as internal or leaf like in the example image
                            if (n.l || n.r) nd.classList.add('internal');
                            else nd.classList.add('leaf');

                            wrap.appendChild(nd);

                            // small connector if node has children (keeps spacing consistent)
                            if (n.l || n.r) {
                                const conn = document.createElement('div');
                                conn.className = 'connector';
                                wrap.appendChild(conn);
                            } else {
                                // keep spacing consistent
                                const spacer = document.createElement('div');
                                spacer.style.height = '20px';
                                wrap.appendChild(spacer);
                            }

                            row.appendChild(wrap);
                        });
                        treeBox.appendChild(row);
                    });

                    // draw connectors after layout
                    lastLevels = levels;
                    // use requestAnimationFrame to ensure DOM layout computed
                    requestAnimationFrame(() => drawConnectors(levels));
                }

                // draw smooth curved connectors between parent and child using an SVG overlay
                function drawConnectors(levels) {
                    // remove existing svg if present
                    const prev = treeBox.querySelector('svg.tree-connectors');
                    if (prev) prev.remove();

                    if (!levels || !levels.length) return;

                    // create svg overlay
                    const svgNS = 'http://www.w3.org/2000/svg';
                    const svg = document.createElementNS(svgNS, 'svg');
                    svg.classList.add('tree-connectors');
                    svg.setAttribute('width', '100%');
                    // set height to the scrollHeight so it covers everything
                    const height = Math.max(treeBox.scrollHeight, treeBox.clientHeight);
                    svg.setAttribute('height', height);
                    svg.setAttribute('viewBox', `0 0 ${treeBox.clientWidth} ${height}`);
                    svg.style.position = 'absolute';
                    svg.style.left = '0';
                    svg.style.top = '0';
                    svg.style.overflow = 'visible';
                    svg.style.zIndex = '1'; // below node-wrap (which has z-index:2)
                    treeBox.appendChild(svg);

                    const containerRect = treeBox.getBoundingClientRect();

                    // helper to find element by node id
                    function findElemByNodeId(id) {
                        return treeBox.querySelector(`[data-node-id="${id}"]`);
                    }

                    // for each node, draw to its left and right children if present
                    levels.forEach((nodes) => {
                        nodes.forEach(n => {
                            if (n.l) drawEdge(n.id, n.l.id);
                            if (n.r) drawEdge(n.id, n.r.id);
                        });
                    });

                    function drawEdge(parentId, childId) {
                        const pEl = findElemByNodeId(parentId);
                        const cEl = findElemByNodeId(childId);
                        if (!pEl || !cEl) return;

                        const pRect = pEl.getBoundingClientRect();
                        const cRect = cEl.getBoundingClientRect();

                        // compute coordinates relative to svg's coordinate system (treeBox top-left = 0,0)
                        const x1 = (pRect.left + pRect.width / 2) - containerRect.left;
                        const y1 = (pRect.top + pRect.height) - containerRect.top; // bottom of parent node
                        const x2 = (cRect.left + cRect.width / 2) - containerRect.left;
                        const y2 = (cRect.top) - containerRect.top; // top of child node

                        // control points for a smooth cubic curve
                        const midY = (y1 + y2) / 2;
                        const cp1x = x1;
                        const cp1y = midY;
                        const cp2x = x2;
                        const cp2y = midY;

                        const path = document.createElementNS(svgNS, 'path');
                        const d = `M ${x1} ${y1} C ${cp1x} ${cp1y} ${cp2x} ${cp2y} ${x2} ${y2}`;
                        path.setAttribute('d', d);
                        path.setAttribute('fill', 'none');
                        path.setAttribute('stroke', 'rgba(34,197,94,0.9)');
                        path.setAttribute('stroke-width', '2.5');
                        path.setAttribute('stroke-linecap', 'round');
                        path.setAttribute('stroke-linejoin', 'round');
                        // subtle shadow
                        path.style.filter = 'drop-shadow(0 2px 4px rgba(0,0,0,0.06))';
                        svg.appendChild(path);
                    }
                }

                // redraw connectors when window resizes or when the tree container is scrolled
                window.addEventListener('resize', () => {
                    if (lastLevels) requestAnimationFrame(() => drawConnectors(lastLevels));
                });
                treeBox.addEventListener('scroll', () => {
                    if (lastLevels) requestAnimationFrame(() => drawConnectors(lastLevels));
                });

                // traversal helpers
                function inorder(n, a) {
                    if (!n) return;
                    inorder(n.l, a);
                    a.push(n.v);
                    inorder(n.r, a);
                }
                function preorder(n, a) {
                    if (!n) return;
                    a.push(n.v);
                    preorder(n.l, a);
                    preorder(n.r, a);
                }
                function postorder(n, a) {
                    if (!n) return;
                    postorder(n.l, a);
                    postorder(n.r, a);
                    a.push(n.v);
                }

                // animate traversal by highlighting nodes in order and showing values inline
                async function animateTraversal(order, label) {
                    if (!root) {
                        traversalOutput.textContent = 'Tree is empty';
                        return;
                    }
                    traversalOutput.textContent = label.toUpperCase() + ': ' + order.join(', ');
                    // clear any existing highlights
                    const prev = treeBox.querySelectorAll('.tree-node.highlight');
                    prev.forEach(el => el.classList.remove('highlight'));

                    // highlight nodes sequentially
                    for (let i = 0; i < order.length; i++) {
                        const val = order[i];
                        // find node element by data-value (string comparison)
                        const el = treeBox.querySelector(`.tree-node[data-value="${val}"]`);
                        if (el) {
                            el.classList.add('highlight');
                            // keep highlight briefly
                            await new Promise(res => setTimeout(res, 550));
                            el.classList.remove('highlight');
                        } else {
                            // if element not found (shouldn't happen), just pause
                            await new Promise(res => setTimeout(res, 250));
                        }
                    }
                }

                function showTraversal(t) {
                    if (!root) {
                        traversalOutput.textContent = 'Tree is empty';
                        return;
                    }
                    const a = [];
                    if (t === 'in') inorder(root, a);
                    if (t === 'pre') preorder(root, a);
                    if (t === 'post') postorder(root, a);
                    // animate and display inline
                    animateTraversal(a, t);
                }

                // Load the perfect example (1..15) as in your image
                function loadPerfectExample() {
                    // build a perfect tree by inserting values in this order (works for BST)
                    const example = [50, 30, 70, 20, 40, 60, 80]; // original sample
                    // but user image used 1..15; provide both options: we'll load 1..15
                    const perfect = [8,4,12,2,6,10,14,1,3,5,7,9,11,13,15]; // insertion order to produce perfect BST 1..15
                    // reset
                    root = null;
                    Node._nextId = 1;
                    // insert perfect 1..15
                    perfect.forEach(v => {
                        root = insertNode(root, v);
                    });
                    renderTree();
                    traversalOutput.textContent = 'Loaded perfect tree with nodes 1..15';
                }

                // Attach events
                stackPushBtn.addEventListener('click', stackPush);
                stackPopBtn.addEventListener('click', stackPop);
                stackClearBtn.addEventListener('click', stackClear);

                queueEnqBtn.addEventListener('click', queueEnq);
                queueDeqBtn.addEventListener('click', queueDeq);
                queueClearBtn.addEventListener('click', queueClear);

                treeInsertBtn.addEventListener('click', treeInsert);
                treeClearBtn.addEventListener('click', treeClear);
                inorderBtn.addEventListener('click', () => showTraversal('in'));
                preorderBtn.addEventListener('click', () => showTraversal('pre'));
                postorderBtn.addEventListener('click', () => showTraversal('post'));
                loadExampleBtn.addEventListener('click', loadPerfectExample);

                // allow hitting Enter for each control (convenience)
                stackInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') stackPush(); });
                queueInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') queueEnq(); });
                treeInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') treeInsert(); });

                // initialize UI
                renderStack();
                renderQueue();
                renderTree();
            });
        </script>

        <!-- ================= DATA STRUCTURES (CODE EXAMPLES) ================= -->
        <section id="datastructures" class="p-6 mt-10 bg-gray-50 rounded-xl max-w-4xl mx-auto">
            <h2 class="text-2xl font-bold mb-4">Data Structures Implementations</h2>

            <div class="mb-6">
                <h3 class="font-semibold text-lg">Array (C++)</h3>
                <pre class="bg-gray-900 text-white p-3 rounded"><code>#include &lt;iostream&gt;
using namespace std;
int main(){ int a[5]={1,2,3,4,5}; for(int i=0;i<5;i++) cout&lt;&lt;a[i]&lt;&lt;" "; }</code></pre>
            </div>

            <div class="mb-6">
                <h3 class="font-semibold text-lg">Stack (Python)</h3>
                <pre class="bg-gray-900 text-white p-3 rounded"><code>stack=[]
stack.append(10)
stack.append(20)
print(stack.pop())</code></pre>
            </div>

            <div class="mb-6">
                <h3 class="font-semibold text-lg">Queue (Python)</h3>
                <pre class="bg-gray-900 text-white p-3 rounded"><code>from collections import deque
q=deque()
q.append(1)
q.append(2)
print(q.popleft())</code></pre>
            </div>

            <div>
                <h3 class="font-semibold text-lg">Binary Tree Traversal (Python)</h3>
                <pre class="bg-gray-900 text-white p-3 rounded"><code>def inorder(n):
    if n:
        inorder(n.left)
        print(n.data)
        inorder(n.right)</code></pre>
            </div>
        </section>
    </main>
</body>
</html>
